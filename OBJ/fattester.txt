; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\fattester.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\fattester.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\FWLIB\inc -I..\FWLIB\src -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FATFS\exfuns -I..\FATFS\src -I..\FATFS\src\option -I..\TEXT -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\KEY -IF:\文档\研究生项目\无线门禁系统\wirelessroom_device_master\USER\RTE\_Target -IC:\Work\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Work\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\fattester.crf ..\FATFS\exfuns\fattester.c]
                          THUMB

                          AREA ||i.mf_close||, CODE, READONLY, ALIGN=2

                  mf_close PROC
;;;40     //返回值:执行结果
;;;41     u8 mf_close(void)
000000  b510              PUSH     {r4,lr}
;;;42     {
;;;43     	f_close(file);
000002  4803              LDR      r0,|L1.16|
000004  6800              LDR      r0,[r0,#0]  ; file
000006  f7fffffe          BL       f_close
;;;44     	return 0;
00000a  2000              MOVS     r0,#0
;;;45     }
00000c  bd10              POP      {r4,pc}
;;;46     //读出数据
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      file

                          AREA ||i.mf_closedir||, CODE, READONLY, ALIGN=2

                  mf_closedir PROC
;;;111    //返回值:执行结果
;;;112    u8 mf_closedir(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114    	return f_closedir(&dir);	
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       f_closedir
;;;115    }
000008  bd10              POP      {r4,pc}
;;;116    //打读取文件夹
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||dir||

                          AREA ||i.mf_fmkfs||, CODE, READONLY, ALIGN=1

                  mf_fmkfs PROC
;;;253    //返回值:执行结果
;;;254    u8 mf_fmkfs(u8* path,u8 mode,u16 au)
000000  b570              PUSH     {r4-r6,lr}
;;;255    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;256    	return f_mkfs((const TCHAR*)path,mode,au);//格式化,drv:盘符;mode:模式;au:簇大小
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       f_mkfs
;;;257    } 
000012  bd70              POP      {r4-r6,pc}
;;;258    //删除文件/目录
                          ENDP


                          AREA ||i.mf_getlabel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  mf_getlabel PROC
;;;275    //path:磁盘路径，比如"0:"、"1:"  
;;;276    void mf_getlabel(u8 *path)
000000  b530              PUSH     {r4,r5,lr}
;;;277    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;278    	u8 buf[20];
;;;279    	u32 sn=0;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;280    	u8 res;
;;;281    	res=f_getlabel ((const TCHAR *)path,(TCHAR *)buf,(DWORD*)&sn);
00000a  aa01              ADD      r2,sp,#4
00000c  a902              ADD      r1,sp,#8
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       f_getlabel
000014  4605              MOV      r5,r0
;;;282    	if(res==FR_OK)
000016  b955              CBNZ     r5,|L4.46|
;;;283    	{
;;;284    		printf("\r\n磁盘%s 的盘符为:%s\r\n",path,buf);
000018  aa02              ADD      r2,sp,#8
00001a  4621              MOV      r1,r4
00001c  a007              ADR      r0,|L4.60|
00001e  f7fffffe          BL       __2printf
;;;285    		printf("磁盘%s 的序列号:%X\r\n\r\n",path,sn); 
000022  4621              MOV      r1,r4
000024  a00b              ADR      r0,|L4.84|
000026  9a01              LDR      r2,[sp,#4]
000028  f7fffffe          BL       __2printf
00002c  e003              B        |L4.54|
                  |L4.46|
;;;286    	}else printf("\r\n获取失败，错误码:%X\r\n",res);
00002e  4629              MOV      r1,r5
000030  a00e              ADR      r0,|L4.108|
000032  f7fffffe          BL       __2printf
                  |L4.54|
;;;287    }
000036  b007              ADD      sp,sp,#0x1c
000038  bd30              POP      {r4,r5,pc}
;;;288    //设置盘符（磁盘名字），最长11个字符！！，支持数字和大写字母组合以及汉字等
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
00003c  0d0ab4c5          DCB      "\r\n",180,197,197,204,"%s ",181,196,197,204,183,251,206
000040  c5cc2573
000044  20b5c4c5
000048  ccb7fbce
00004c  aa3a2573          DCB      170,":%s\r\n",0
000050  0d0a00  
000053  00                DCB      0
                  |L4.84|
000054  b4c5c5cc          DCB      180,197,197,204,"%s ",181,196,208,242,193,208,186,197,":"
000058  257320b5
00005c  c4d0f2c1
000060  d0bac53a
000064  25580d0a          DCB      "%X\r\n\r\n",0
000068  0d0a00  
00006b  00                DCB      0
                  |L4.108|
00006c  0d0abbf1          DCB      "\r\n",187,241,200,161,202,167,176,220,163,172,180,237,206
000070  c8a1caa7
000074  b0dca3ac
000078  b4edce  
00007b  f3c2eb3a          DCB      243,194,235,":%X\r\n",0
00007f  25580d0a
000083  00      

                          AREA ||i.mf_gets||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  mf_gets PROC
;;;301    //size:要读取的长度
;;;302    void mf_gets(u16 size)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304     	TCHAR* rbuf;
;;;305    	rbuf=f_gets((TCHAR*)fatbuf,size,file);
000004  4808              LDR      r0,|L5.40|
000006  4621              MOV      r1,r4
000008  6802              LDR      r2,[r0,#0]  ; file
00000a  4808              LDR      r0,|L5.44|
00000c  6800              LDR      r0,[r0,#0]  ; fatbuf
00000e  f7fffffe          BL       f_gets
000012  4605              MOV      r5,r0
;;;306    	if(*rbuf==0)return  ;//没有数据读到
000014  7828              LDRB     r0,[r5,#0]
000016  b900              CBNZ     r0,|L5.26|
                  |L5.24|
;;;307    	else
;;;308    	{
;;;309    		printf("\r\nThe String Readed Is:%s\r\n",rbuf);  	  
;;;310    	}			    	
;;;311    }
000018  bd70              POP      {r4-r6,pc}
                  |L5.26|
00001a  4629              MOV      r1,r5                 ;309
00001c  a004              ADR      r0,|L5.48|
00001e  f7fffffe          BL       __2printf
000022  bf00              NOP      
000024  e7f8              B        |L5.24|
;;;312    //需要_USE_STRFUNC>=1
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      file
                  |L5.44|
                          DCD      fatbuf
                  |L5.48|
000030  0d0a5468          DCB      "\r\nThe String Readed Is:%s\r\n",0
000034  65205374
000038  72696e67
00003c  20526561
000040  64656420
000044  49733a25
000048  730d0a00

                          AREA ||i.mf_lseek||, CODE, READONLY, ALIGN=2

                  mf_lseek PROC
;;;225    //返回值:执行结果.
;;;226    u8 mf_lseek(u32 offset)
000000  b510              PUSH     {r4,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228    	return f_lseek(file,offset);
000004  4621              MOV      r1,r4
000006  4802              LDR      r0,|L6.16|
000008  6800              LDR      r0,[r0,#0]  ; file
00000a  f7fffffe          BL       f_lseek
;;;229    }
00000e  bd10              POP      {r4,pc}
;;;230    //读取文件当前读写指针的位置.
                          ENDP

                  |L6.16|
                          DCD      file

                          AREA ||i.mf_mkdir||, CODE, READONLY, ALIGN=1

                  mf_mkdir PROC
;;;244    //返回值:执行结果
;;;245    u8 mf_mkdir(u8*pname)
000000  b510              PUSH     {r4,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247    	return f_mkdir((const TCHAR *)pname);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_mkdir
;;;248    }
00000a  bd10              POP      {r4,pc}
;;;249    //格式化
                          ENDP


                          AREA ||i.mf_mount||, CODE, READONLY, ALIGN=2

                  mf_mount PROC
;;;24     //返回值:执行结果
;;;25     u8 mf_mount(u8* path,u8 mt)
000000  b570              PUSH     {r4-r6,lr}
;;;26     {		   
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;27     	return f_mount(fs[2],(const TCHAR*)path,mt); 
000006  4903              LDR      r1,|L8.20|
000008  462a              MOV      r2,r5
00000a  6888              LDR      r0,[r1,#8]  ; fs
00000c  4621              MOV      r1,r4
00000e  f7fffffe          BL       f_mount
;;;28     }
000012  bd70              POP      {r4-r6,pc}
;;;29     //打开路径下的文件
                          ENDP

                  |L8.20|
                          DCD      ||fs||

                          AREA ||i.mf_open||, CODE, READONLY, ALIGN=2

                  mf_open PROC
;;;32     //返回值:执行结果
;;;33     u8 mf_open(u8*path,u8 mode)
000000  b570              PUSH     {r4-r6,lr}
;;;34     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;35     	u8 res;	 
;;;36     	res=f_open(file,(const TCHAR*)path,mode);//打开文件夹
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  4803              LDR      r0,|L9.24|
00000c  6800              LDR      r0,[r0,#0]  ; file
00000e  f7fffffe          BL       f_open
000012  4606              MOV      r6,r0
;;;37     	return res;
000014  4630              MOV      r0,r6
;;;38     } 
000016  bd70              POP      {r4-r6,pc}
;;;39     //关闭文件
                          ENDP

                  |L9.24|
                          DCD      file

                          AREA ||i.mf_opendir||, CODE, READONLY, ALIGN=2

                  mf_opendir PROC
;;;105    //返回值:执行结果
;;;106    u8 mf_opendir(u8* path)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return f_opendir(&dir,(const TCHAR*)path);	
000004  4621              MOV      r1,r4
000006  4802              LDR      r0,|L10.16|
000008  f7fffffe          BL       f_opendir
;;;109    }
00000c  bd10              POP      {r4,pc}
;;;110    //关闭目录 
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||dir||

                          AREA ||i.mf_putc||, CODE, READONLY, ALIGN=2

                  mf_putc PROC
;;;315    //返回值:执行结果
;;;316    u8 mf_putc(u8 c)
000000  b510              PUSH     {r4,lr}
;;;317    {
000002  4604              MOV      r4,r0
;;;318    	return f_putc((TCHAR)c,file);
000004  4803              LDR      r0,|L11.20|
000006  6801              LDR      r1,[r0,#0]  ; file
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       f_putc
00000e  b2c0              UXTB     r0,r0
;;;319    }
000010  bd10              POP      {r4,pc}
;;;320    //写字符串到文件
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      file

                          AREA ||i.mf_puts||, CODE, READONLY, ALIGN=2

                  mf_puts PROC
;;;322    //返回值:写入的字符串长度
;;;323    u8 mf_puts(u8*c)
000000  b510              PUSH     {r4,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325    	return f_puts((TCHAR*)c,file);
000004  4803              LDR      r0,|L12.20|
000006  6801              LDR      r1,[r0,#0]  ; file
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       f_puts
00000e  b2c0              UXTB     r0,r0
;;;326    }
000010  bd10              POP      {r4,pc}
;;;327    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      file

                          AREA ||i.mf_read||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mf_read PROC
;;;48     //返回值:执行结果
;;;49     u8 mf_read(u16 len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;50     {
000004  4604              MOV      r4,r0
;;;51     	u16 i,t;
;;;52     	u8 res=0;
000006  2600              MOVS     r6,#0
;;;53     	u16 tlen=0;
000008  2700              MOVS     r7,#0
;;;54     	printf("\r\nRead file data is:\r\n");
00000a  a035              ADR      r0,|L13.224|
00000c  f7fffffe          BL       __2printf
;;;55     	for(i=0;i<len/512;i++)
000010  46b1              MOV      r9,r6
000012  e025              B        |L13.96|
                  |L13.20|
;;;56     	{
;;;57     		res=f_read(file,fatbuf,512,&br);
000014  4b38              LDR      r3,|L13.248|
000016  f44f7200          MOV      r2,#0x200
00001a  4838              LDR      r0,|L13.252|
00001c  6801              LDR      r1,[r0,#0]  ; fatbuf
00001e  4838              LDR      r0,|L13.256|
000020  6800              LDR      r0,[r0,#0]  ; file
000022  f7fffffe          BL       f_read
000026  4606              MOV      r6,r0
;;;58     		if(res)
000028  b126              CBZ      r6,|L13.52|
;;;59     		{
;;;60     			printf("Read Error:%d\r\n",res);
00002a  4631              MOV      r1,r6
00002c  a035              ADR      r0,|L13.260|
00002e  f7fffffe          BL       __2printf
;;;61     			break;
000032  e01b              B        |L13.108|
                  |L13.52|
;;;62     		}else
;;;63     		{
;;;64     			tlen+=br;
000034  4830              LDR      r0,|L13.248|
000036  8800              LDRH     r0,[r0,#0]  ; br
000038  4438              ADD      r0,r0,r7
00003a  b287              UXTH     r7,r0
;;;65     			for(t=0;t<br;t++)printf("%c",fatbuf[t]); 
00003c  2500              MOVS     r5,#0
00003e  e007              B        |L13.80|
                  |L13.64|
000040  482e              LDR      r0,|L13.252|
000042  6800              LDR      r0,[r0,#0]  ; fatbuf
000044  5d41              LDRB     r1,[r0,r5]
000046  a033              ADR      r0,|L13.276|
000048  f7fffffe          BL       __2printf
00004c  1c68              ADDS     r0,r5,#1
00004e  b285              UXTH     r5,r0
                  |L13.80|
000050  4829              LDR      r0,|L13.248|
000052  6800              LDR      r0,[r0,#0]  ; br
000054  4285              CMP      r5,r0
000056  d3f3              BCC      |L13.64|
000058  f1090001          ADD      r0,r9,#1              ;55
00005c  fa1ff980          UXTH     r9,r0                 ;55
                  |L13.96|
000060  17e1              ASRS     r1,r4,#31             ;55
000062  eb0451d1          ADD      r1,r4,r1,LSR #23      ;55
000066  ebb92f61          CMP      r9,r1,ASR #9          ;55
00006a  dbd3              BLT      |L13.20|
                  |L13.108|
00006c  bf00              NOP                            ;61
;;;66     		}
;;;67     	}
;;;68     	if(len%512)
00006e  17e1              ASRS     r1,r4,#31
000070  eb0451d1          ADD      r1,r4,r1,LSR #23
000074  1249              ASRS     r1,r1,#9
000076  eba42141          SUB      r1,r4,r1,LSL #9
00007a  b331              CBZ      r1,|L13.202|
;;;69     	{
;;;70     		res=f_read(file,fatbuf,len%512,&br);
00007c  46a0              MOV      r8,r4
00007e  17e0              ASRS     r0,r4,#31
000080  eb0450d0          ADD      r0,r4,r0,LSR #23
000084  1240              ASRS     r0,r0,#9
000086  eba42240          SUB      r2,r4,r0,LSL #9
00008a  4b1b              LDR      r3,|L13.248|
00008c  481b              LDR      r0,|L13.252|
00008e  6801              LDR      r1,[r0,#0]  ; fatbuf
000090  481b              LDR      r0,|L13.256|
000092  6800              LDR      r0,[r0,#0]  ; file
000094  f7fffffe          BL       f_read
000098  4606              MOV      r6,r0
;;;71     		if(res)	//读数据出错了
00009a  b126              CBZ      r6,|L13.166|
;;;72     		{
;;;73     			printf("\r\nRead Error:%d\r\n",res);   
00009c  4631              MOV      r1,r6
00009e  a01e              ADR      r0,|L13.280|
0000a0  f7fffffe          BL       __2printf
0000a4  e011              B        |L13.202|
                  |L13.166|
;;;74     		}else
;;;75     		{
;;;76     			tlen+=br;
0000a6  4814              LDR      r0,|L13.248|
0000a8  8800              LDRH     r0,[r0,#0]  ; br
0000aa  4438              ADD      r0,r0,r7
0000ac  b287              UXTH     r7,r0
;;;77     			for(t=0;t<br;t++)printf("%c",fatbuf[t]); 
0000ae  2500              MOVS     r5,#0
0000b0  e007              B        |L13.194|
                  |L13.178|
0000b2  4812              LDR      r0,|L13.252|
0000b4  6800              LDR      r0,[r0,#0]  ; fatbuf
0000b6  5d41              LDRB     r1,[r0,r5]
0000b8  a016              ADR      r0,|L13.276|
0000ba  f7fffffe          BL       __2printf
0000be  1c68              ADDS     r0,r5,#1
0000c0  b285              UXTH     r5,r0
                  |L13.194|
0000c2  480d              LDR      r0,|L13.248|
0000c4  6800              LDR      r0,[r0,#0]  ; br
0000c6  4285              CMP      r5,r0
0000c8  d3f3              BCC      |L13.178|
                  |L13.202|
;;;78     		}	 
;;;79     	}
;;;80     	if(tlen)printf("\r\nReaded data len:%d\r\n",tlen);//读到的数据长度
0000ca  b11f              CBZ      r7,|L13.212|
0000cc  4639              MOV      r1,r7
0000ce  a017              ADR      r0,|L13.300|
0000d0  f7fffffe          BL       __2printf
                  |L13.212|
;;;81     	printf("Read data over\r\n");	 
0000d4  a01b              ADR      r0,|L13.324|
0000d6  f7fffffe          BL       __2printf
;;;82     	return res;
0000da  4630              MOV      r0,r6
;;;83     }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;84     //写入数据
                          ENDP

                  |L13.224|
0000e0  0d0a5265          DCB      "\r\nRead file data is:\r\n",0
0000e4  61642066
0000e8  696c6520
0000ec  64617461
0000f0  2069733a
0000f4  0d0a00  
0000f7  00                DCB      0
                  |L13.248|
                          DCD      ||br||
                  |L13.252|
                          DCD      fatbuf
                  |L13.256|
                          DCD      file
                  |L13.260|
000104  52656164          DCB      "Read Error:%d\r\n",0
000108  20457272
00010c  6f723a25
000110  640d0a00
                  |L13.276|
000114  256300            DCB      "%c",0
000117  00                DCB      0
                  |L13.280|
000118  0d0a5265          DCB      "\r\nRead Error:%d\r\n",0
00011c  61642045
000120  72726f72
000124  3a25640d
000128  0a00    
00012a  00                DCB      0
00012b  00                DCB      0
                  |L13.300|
00012c  0d0a5265          DCB      "\r\nReaded data len:%d\r\n",0
000130  61646564
000134  20646174
000138  61206c65
00013c  6e3a2564
000140  0d0a00  
000143  00                DCB      0
                  |L13.324|
000144  52656164          DCB      "Read data over\r\n",0
000148  20646174
00014c  61206f76
000150  65720d0a
000154  00      
000155  00                DCB      0
000156  00                DCB      0
000157  00                DCB      0

                          AREA ||i.mf_readdir||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  mf_readdir PROC
;;;117    //返回值:执行结果
;;;118    u8 mf_readdir(void)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
;;;120    	u8 res;
;;;121    	char *fn;			 
;;;122    #if _USE_LFN
;;;123     	fileinfo.lfsize = _MAX_LFN * 2 + 1;
000002  f24010ff          MOV      r0,#0x1ff
000006  4931              LDR      r1,|L14.204|
000008  61c8              STR      r0,[r1,#0x1c]  ; fileinfo
;;;124    	fileinfo.lfname = mymalloc(SRAMIN,fileinfo.lfsize);
00000a  4608              MOV      r0,r1
00000c  69c1              LDR      r1,[r0,#0x1c]  ; fileinfo
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       mymalloc
000014  492d              LDR      r1,|L14.204|
000016  6188              STR      r0,[r1,#0x18]  ; fileinfo
;;;125    #endif		  
;;;126    	res=f_readdir(&dir,&fileinfo);//读取一个文件的信息
000018  482d              LDR      r0,|L14.208|
00001a  f7fffffe          BL       f_readdir
00001e  4604              MOV      r4,r0
;;;127    	if(res!=FR_OK||fileinfo.fname[0]==0)
000020  b914              CBNZ     r4,|L14.40|
000022  482a              LDR      r0,|L14.204|
000024  7a40              LDRB     r0,[r0,#9]  ; fileinfo
000026  b930              CBNZ     r0,|L14.54|
                  |L14.40|
;;;128    	{
;;;129    		myfree(SRAMIN,fileinfo.lfname);
000028  4828              LDR      r0,|L14.204|
00002a  6981              LDR      r1,[r0,#0x18]  ; fileinfo
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       myfree
;;;130    		return res;//读完了.
000032  4620              MOV      r0,r4
                  |L14.52|
;;;131    	}
;;;132    #if _USE_LFN
;;;133    	fn=*fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;
;;;134    #else
;;;135    	fn=fileinfo.fname;;
;;;136    #endif	
;;;137    	printf("\r\n DIR info:\r\n");
;;;138    
;;;139    	printf("dir.id:%d\r\n",dir.id);
;;;140    	printf("dir.index:%d\r\n",dir.index);
;;;141    	printf("dir.sclust:%d\r\n",dir.sclust);
;;;142    	printf("dir.clust:%d\r\n",dir.clust);
;;;143    	printf("dir.sect:%d\r\n",dir.sect);	  
;;;144    
;;;145    	printf("\r\n");
;;;146    	printf("File Name is:%s\r\n",fn);
;;;147    	printf("File Size is:%d\r\n",fileinfo.fsize);
;;;148    	printf("File data is:%d\r\n",fileinfo.fdate);
;;;149    	printf("File time is:%d\r\n",fileinfo.ftime);
;;;150    	printf("File Attr is:%d\r\n",fileinfo.fattrib);
;;;151    	printf("\r\n");
;;;152    	myfree(SRAMIN,fileinfo.lfname);
;;;153    	return 0;
;;;154    }			 
000034  bd70              POP      {r4-r6,pc}
                  |L14.54|
000036  4825              LDR      r0,|L14.204|
000038  6980              LDR      r0,[r0,#0x18]         ;133  ; fileinfo
00003a  7800              LDRB     r0,[r0,#0]            ;133
00003c  b110              CBZ      r0,|L14.68|
00003e  4823              LDR      r0,|L14.204|
000040  6980              LDR      r0,[r0,#0x18]         ;133  ; fileinfo
000042  e001              B        |L14.72|
                  |L14.68|
000044  4821              LDR      r0,|L14.204|
000046  3009              ADDS     r0,r0,#9              ;133
                  |L14.72|
000048  4605              MOV      r5,r0                 ;133
00004a  a022              ADR      r0,|L14.212|
00004c  f7fffffe          BL       __2printf
000050  481f              LDR      r0,|L14.208|
000052  8881              LDRH     r1,[r0,#4]            ;139  ; dir
000054  a023              ADR      r0,|L14.228|
000056  f7fffffe          BL       __2printf
00005a  481d              LDR      r0,|L14.208|
00005c  88c1              LDRH     r1,[r0,#6]            ;140  ; dir
00005e  a024              ADR      r0,|L14.240|
000060  f7fffffe          BL       __2printf
000064  481a              LDR      r0,|L14.208|
000066  6881              LDR      r1,[r0,#8]            ;141  ; dir
000068  a025              ADR      r0,|L14.256|
00006a  f7fffffe          BL       __2printf
00006e  4818              LDR      r0,|L14.208|
000070  68c1              LDR      r1,[r0,#0xc]          ;142  ; dir
000072  a027              ADR      r0,|L14.272|
000074  f7fffffe          BL       __2printf
000078  4815              LDR      r0,|L14.208|
00007a  6901              LDR      r1,[r0,#0x10]         ;143  ; dir
00007c  a028              ADR      r0,|L14.288|
00007e  f7fffffe          BL       __2printf
000082  a017              ADR      r0,|L14.224|
000084  f7fffffe          BL       __2printf
000088  4629              MOV      r1,r5                 ;146
00008a  a029              ADR      r0,|L14.304|
00008c  f7fffffe          BL       __2printf
000090  480e              LDR      r0,|L14.204|
000092  6801              LDR      r1,[r0,#0]            ;147  ; fileinfo
000094  a02b              ADR      r0,|L14.324|
000096  f7fffffe          BL       __2printf
00009a  480c              LDR      r0,|L14.204|
00009c  8881              LDRH     r1,[r0,#4]            ;148  ; fileinfo
00009e  a02e              ADR      r0,|L14.344|
0000a0  f7fffffe          BL       __2printf
0000a4  4809              LDR      r0,|L14.204|
0000a6  88c1              LDRH     r1,[r0,#6]            ;149  ; fileinfo
0000a8  a030              ADR      r0,|L14.364|
0000aa  f7fffffe          BL       __2printf
0000ae  4807              LDR      r0,|L14.204|
0000b0  7a01              LDRB     r1,[r0,#8]            ;150  ; fileinfo
0000b2  a033              ADR      r0,|L14.384|
0000b4  f7fffffe          BL       __2printf
0000b8  a009              ADR      r0,|L14.224|
0000ba  f7fffffe          BL       __2printf
0000be  4803              LDR      r0,|L14.204|
0000c0  6981              LDR      r1,[r0,#0x18]         ;152  ; fileinfo
0000c2  2000              MOVS     r0,#0                 ;152
0000c4  f7fffffe          BL       myfree
0000c8  2000              MOVS     r0,#0                 ;153
0000ca  e7b3              B        |L14.52|
;;;155    
                          ENDP

                  |L14.204|
                          DCD      fileinfo
                  |L14.208|
                          DCD      ||dir||
                  |L14.212|
0000d4  0d0a2044          DCB      "\r\n DIR info:"
0000d8  49522069
0000dc  6e666f3a
                  |L14.224|
0000e0  0d0a00            DCB      "\r\n",0
0000e3  00                DCB      0
                  |L14.228|
0000e4  6469722e          DCB      "dir.id:%d\r\n",0
0000e8  69643a25
0000ec  640d0a00
                  |L14.240|
0000f0  6469722e          DCB      "dir.index:%d\r\n",0
0000f4  696e6465
0000f8  783a2564
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L14.256|
000100  6469722e          DCB      "dir.sclust:%d\r\n",0
000104  73636c75
000108  73743a25
00010c  640d0a00
                  |L14.272|
000110  6469722e          DCB      "dir.clust:%d\r\n",0
000114  636c7573
000118  743a2564
00011c  0d0a00  
00011f  00                DCB      0
                  |L14.288|
000120  6469722e          DCB      "dir.sect:%d\r\n",0
000124  73656374
000128  3a25640d
00012c  0a00    
00012e  00                DCB      0
00012f  00                DCB      0
                  |L14.304|
000130  46696c65          DCB      "File Name is:%s\r\n",0
000134  204e616d
000138  65206973
00013c  3a25730d
000140  0a00    
000142  00                DCB      0
000143  00                DCB      0
                  |L14.324|
000144  46696c65          DCB      "File Size is:%d\r\n",0
000148  2053697a
00014c  65206973
000150  3a25640d
000154  0a00    
000156  00                DCB      0
000157  00                DCB      0
                  |L14.344|
000158  46696c65          DCB      "File data is:%d\r\n",0
00015c  20646174
000160  61206973
000164  3a25640d
000168  0a00    
00016a  00                DCB      0
00016b  00                DCB      0
                  |L14.364|
00016c  46696c65          DCB      "File time is:%d\r\n",0
000170  2074696d
000174  65206973
000178  3a25640d
00017c  0a00    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L14.384|
000180  46696c65          DCB      "File Attr is:%d\r\n",0
000184  20417474
000188  72206973
00018c  3a25640d
000190  0a00    
000192  00                DCB      0
000193  00                DCB      0

                          AREA ||i.mf_rename||, CODE, READONLY, ALIGN=1

                  mf_rename PROC
;;;269    //返回值:执行结果
;;;270    u8 mf_rename(u8 *oldname,u8* newname)
000000  b570              PUSH     {r4-r6,lr}
;;;271    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;272    	return  f_rename((const TCHAR *)oldname,(const TCHAR *)newname);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       f_rename
;;;273    }
00000e  bd70              POP      {r4-r6,pc}
;;;274    //获取盘符（磁盘名字）
                          ENDP


                          AREA ||i.mf_scan_files||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mf_scan_files PROC
;;;158     //返回值:执行结果
;;;159    u8 mf_scan_files(u8 * path)
000000  b570              PUSH     {r4-r6,lr}
;;;160    {
000002  4605              MOV      r5,r0
;;;161    	FRESULT res;	  
;;;162        char *fn;   /* This function is assuming non-Unicode cfg. */
;;;163    #if _USE_LFN
;;;164     	fileinfo.lfsize = _MAX_LFN * 2 + 1;
000004  f24010ff          MOV      r0,#0x1ff
000008  491b              LDR      r1,|L16.120|
00000a  61c8              STR      r0,[r1,#0x1c]  ; fileinfo
;;;165    	fileinfo.lfname = mymalloc(SRAMIN,fileinfo.lfsize);
00000c  4608              MOV      r0,r1
00000e  69c1              LDR      r1,[r0,#0x1c]  ; fileinfo
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       mymalloc
000016  4918              LDR      r1,|L16.120|
000018  6188              STR      r0,[r1,#0x18]  ; fileinfo
;;;166    #endif		  
;;;167    
;;;168        res = f_opendir(&dir,(const TCHAR*)path); //打开一个目录
00001a  4629              MOV      r1,r5
00001c  4817              LDR      r0,|L16.124|
00001e  f7fffffe          BL       f_opendir
000022  4604              MOV      r4,r0
;;;169        if (res == FR_OK) 
000024  bb0c              CBNZ     r4,|L16.106|
;;;170    	{	
;;;171    		printf("\r\n"); 
000026  a016              ADR      r0,|L16.128|
000028  f7fffffe          BL       __2printf
;;;172    		while(1)
00002c  e01b              B        |L16.102|
                  |L16.46|
;;;173    		{
;;;174    	        res = f_readdir(&dir, &fileinfo);                   //读取目录下的一个文件
00002e  4912              LDR      r1,|L16.120|
000030  4812              LDR      r0,|L16.124|
000032  f7fffffe          BL       f_readdir
000036  4604              MOV      r4,r0
;;;175    	        if (res != FR_OK || fileinfo.fname[0] == 0) break;  //错误了/到末尾了,退出
000038  b914              CBNZ     r4,|L16.64|
00003a  480f              LDR      r0,|L16.120|
00003c  7a40              LDRB     r0,[r0,#9]  ; fileinfo
00003e  b900              CBNZ     r0,|L16.66|
                  |L16.64|
000040  e012              B        |L16.104|
                  |L16.66|
;;;176    	        //if (fileinfo.fname[0] == '.') continue;             //忽略上级目录
;;;177    #if _USE_LFN
;;;178            	fn = *fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;
000042  480d              LDR      r0,|L16.120|
000044  6980              LDR      r0,[r0,#0x18]  ; fileinfo
000046  7800              LDRB     r0,[r0,#0]
000048  b110              CBZ      r0,|L16.80|
00004a  480b              LDR      r0,|L16.120|
00004c  6980              LDR      r0,[r0,#0x18]  ; fileinfo
00004e  e001              B        |L16.84|
                  |L16.80|
000050  4809              LDR      r0,|L16.120|
000052  3009              ADDS     r0,r0,#9
                  |L16.84|
000054  4606              MOV      r6,r0
;;;179    #else							   
;;;180            	fn = fileinfo.fname;
;;;181    #endif	                                              /* It is a file. */
;;;182    			printf("%s/", path);//打印路径	
000056  4629              MOV      r1,r5
000058  a00a              ADR      r0,|L16.132|
00005a  f7fffffe          BL       __2printf
;;;183    			printf("%s\r\n",  fn);//打印文件名	  
00005e  4631              MOV      r1,r6
000060  a009              ADR      r0,|L16.136|
000062  f7fffffe          BL       __2printf
                  |L16.102|
000066  e7e2              B        |L16.46|
                  |L16.104|
000068  bf00              NOP                            ;175
                  |L16.106|
;;;184    		} 
;;;185        }	  
;;;186    	myfree(SRAMIN,fileinfo.lfname);
00006a  4803              LDR      r0,|L16.120|
00006c  6981              LDR      r1,[r0,#0x18]  ; fileinfo
00006e  2000              MOVS     r0,#0
000070  f7fffffe          BL       myfree
;;;187        return res;	  
000074  4620              MOV      r0,r4
;;;188    }
000076  bd70              POP      {r4-r6,pc}
;;;189    //显示剩余容量
                          ENDP

                  |L16.120|
                          DCD      fileinfo
                  |L16.124|
                          DCD      ||dir||
                  |L16.128|
000080  0d0a00            DCB      "\r\n",0
000083  00                DCB      0
                  |L16.132|
000084  25732f00          DCB      "%s/",0
                  |L16.136|
000088  25730d0a          DCB      "%s\r\n",0
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.mf_setlabel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  mf_setlabel PROC
;;;289    //path:磁盘号+名字，比如"0:ALIENTEK"、"1:OPENEDV"  
;;;290    void mf_setlabel(u8 *path)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4604              MOV      r4,r0
;;;292    	u8 res;
;;;293    	res=f_setlabel ((const TCHAR *)path);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_setlabel
00000a  4605              MOV      r5,r0
;;;294    	if(res==FR_OK)
00000c  b925              CBNZ     r5,|L17.24|
;;;295    	{
;;;296    		printf("\r\n磁盘盘符设置成功:%s\r\n",path);
00000e  4621              MOV      r1,r4
000010  a004              ADR      r0,|L17.36|
000012  f7fffffe          BL       __2printf
000016  e003              B        |L17.32|
                  |L17.24|
;;;297    	}else printf("\r\n磁盘盘符设置失败，错误码:%X\r\n",res);
000018  4629              MOV      r1,r5
00001a  a008              ADR      r0,|L17.60|
00001c  f7fffffe          BL       __2printf
                  |L17.32|
;;;298    } 
000020  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
000024  0d0ab4c5          DCB      "\r\n",180,197,197,204,197,204,183,251,201,232,214,195,179
000028  c5ccc5cc
00002c  b7fbc9e8
000030  d6c3b3  
000033  c9b9a63a          DCB      201,185,166,":%s\r\n",0
000037  25730d0a
00003b  00      
                  |L17.60|
00003c  0d0ab4c5          DCB      "\r\n",180,197,197,204,197,204,183,251,201,232,214,195,202
000040  c5ccc5cc
000044  b7fbc9e8
000048  d6c3ca  
00004b  a7b0dca3          DCB      167,176,220,163,172,180,237,206,243,194,235,":%X\r\n",0
00004f  acb4edce
000053  f3c2eb3a
000057  25580d0a
00005b  00      

                          AREA ||i.mf_showfree||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  mf_showfree PROC
;;;191    //返回值:剩余容量(字节)
;;;192    u32 mf_showfree(u8 *drv)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;193    {
000004  4606              MOV      r6,r0
;;;194    	FATFS *fs1;
;;;195    	u8 res;
;;;196        u32 fre_clust=0, fre_sect=0, tot_sect=0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  2400              MOVS     r4,#0
00000c  2500              MOVS     r5,#0
;;;197        //得到磁盘信息及空闲簇数量
;;;198        res = f_getfree((const TCHAR*)drv,(DWORD*)&fre_clust, &fs1);
00000e  aa01              ADD      r2,sp,#4
000010  4669              MOV      r1,sp
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       f_getfree
000018  4607              MOV      r7,r0
;;;199        if(res==0)
00001a  2f00              CMP      r7,#0
00001c  d119              BNE      |L18.82|
;;;200    	{											   
;;;201    	    tot_sect = (fs1->n_fatent - 2) * fs1->csize;//得到总扇区数
00001e  9801              LDR      r0,[sp,#4]
000020  6940              LDR      r0,[r0,#0x14]
000022  1e80              SUBS     r0,r0,#2
000024  9901              LDR      r1,[sp,#4]
000026  7889              LDRB     r1,[r1,#2]
000028  fb00f501          MUL      r5,r0,r1
;;;202    	    fre_sect = fre_clust * fs1->csize;			//得到空闲扇区数	   
00002c  9801              LDR      r0,[sp,#4]
00002e  7880              LDRB     r0,[r0,#2]
000030  9900              LDR      r1,[sp,#0]
000032  fb00f401          MUL      r4,r0,r1
;;;203    #if _MAX_SS!=512
;;;204    		tot_sect*=fs1->ssize/512;
;;;205    		fre_sect*=fs1->ssize/512;
;;;206    #endif	  
;;;207    		if(tot_sect<20480)//总容量小于10M
000036  f5b54fa0          CMP      r5,#0x5000
00003a  d205              BCS      |L18.72|
;;;208    		{
;;;209    		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
;;;210    		    printf("\r\n磁盘总容量:%d KB\r\n"
00003c  0862              LSRS     r2,r4,#1
00003e  0869              LSRS     r1,r5,#1
000040  a005              ADR      r0,|L18.88|
000042  f7fffffe          BL       __2printf
000046  e004              B        |L18.82|
                  |L18.72|
;;;211    		           "可用空间:%d KB\r\n",
;;;212    		           tot_sect>>1,fre_sect>>1);
;;;213    		}else
;;;214    		{
;;;215    		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
;;;216    		    printf("\r\n磁盘总容量:%d MB\r\n"
000048  0ae2              LSRS     r2,r4,#11
00004a  0ae9              LSRS     r1,r5,#11
00004c  a00c              ADR      r0,|L18.128|
00004e  f7fffffe          BL       __2printf
                  |L18.82|
;;;217    		           "可用空间:%d MB\r\n",
;;;218    		           tot_sect>>11,fre_sect>>11);
;;;219    		}
;;;220    	}
;;;221    	return fre_sect;
000052  4620              MOV      r0,r4
;;;222    }		    
000054  e8bd81fc          POP      {r2-r8,pc}
;;;223    //文件读写指针偏移
                          ENDP

                  |L18.88|
000058  0d0ab4c5          DCB      "\r\n",180,197,197,204,215,220,200,221,193,191,":%d KB\r"
00005c  c5ccd7dc
000060  c8ddc1bf
000064  3a256420
000068  4b420d  
00006b  0abfc9d3          DCB      "\n",191,201,211,195,191,213,188,228,":%d KB\r\n",0
00006f  c3bfd5bc
000073  e43a2564
000077  204b420d
00007b  0a00    
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L18.128|
000080  0d0ab4c5          DCB      "\r\n",180,197,197,204,215,220,200,221,193,191,":%d MB\r"
000084  c5ccd7dc
000088  c8ddc1bf
00008c  3a256420
000090  4d420d  
000093  0abfc9d3          DCB      "\n",191,201,211,195,191,213,188,228,":%d MB\r\n",0
000097  c3bfd5bc
00009b  e43a2564
00009f  204d420d
0000a3  0a00    
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.mf_size||, CODE, READONLY, ALIGN=2

                  mf_size PROC
;;;237    //返回值:文件大小
;;;238    u32 mf_size(void)
000000  4801              LDR      r0,|L19.8|
;;;239    {
;;;240    	return f_size(file);
000002  6800              LDR      r0,[r0,#0]  ; file
000004  68c0              LDR      r0,[r0,#0xc]
;;;241    } 
000006  4770              BX       lr
;;;242    //创建目录
                          ENDP

                  |L19.8|
                          DCD      file

                          AREA ||i.mf_tell||, CODE, READONLY, ALIGN=2

                  mf_tell PROC
;;;231    //返回值:位置
;;;232    u32 mf_tell(void)
000000  4801              LDR      r0,|L20.8|
;;;233    {
;;;234    	return f_tell(file);
000002  6800              LDR      r0,[r0,#0]  ; file
000004  6880              LDR      r0,[r0,#8]
;;;235    }
000006  4770              BX       lr
;;;236    //读取文件大小
                          ENDP

                  |L20.8|
                          DCD      file

                          AREA ||i.mf_unlink||, CODE, READONLY, ALIGN=1

                  mf_unlink PROC
;;;260    //返回值:执行结果
;;;261    u8 mf_unlink(u8 *pname)
000000  b510              PUSH     {r4,lr}
;;;262    {
000002  4604              MOV      r4,r0
;;;263    	return  f_unlink((const TCHAR *)pname);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_unlink
;;;264    }
00000a  bd10              POP      {r4,pc}
;;;265    
                          ENDP


                          AREA ||i.mf_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  mf_write PROC
;;;87     //返回值:执行结果
;;;88     u8 mf_write(u8*dat,u16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {			    
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;90     	u8 res;	   					   
;;;91     
;;;92     	printf("\r\nBegin Write file...\r\n");
000006  a00f              ADR      r0,|L22.68|
000008  f7fffffe          BL       __2printf
;;;93     	printf("Write data len:%d\r\n",len);	 
00000c  4631              MOV      r1,r6
00000e  a013              ADR      r0,|L22.92|
000010  f7fffffe          BL       __2printf
;;;94     	res=f_write(file,dat,len,&bw);
000014  4b16              LDR      r3,|L22.112|
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4816              LDR      r0,|L22.116|
00001c  6800              LDR      r0,[r0,#0]  ; file
00001e  f7fffffe          BL       f_write
000022  4604              MOV      r4,r0
;;;95     	if(res)
000024  b124              CBZ      r4,|L22.48|
;;;96     	{
;;;97     		printf("Write Error:%d\r\n",res);   
000026  4621              MOV      r1,r4
000028  a013              ADR      r0,|L22.120|
00002a  f7fffffe          BL       __2printf
00002e  e004              B        |L22.58|
                  |L22.48|
;;;98     	}else printf("Writed data len:%d\r\n",bw);
000030  480f              LDR      r0,|L22.112|
000032  6801              LDR      r1,[r0,#0]  ; bw
000034  a015              ADR      r0,|L22.140|
000036  f7fffffe          BL       __2printf
                  |L22.58|
;;;99     	printf("Write data over.\r\n");
00003a  a01a              ADR      r0,|L22.164|
00003c  f7fffffe          BL       __2printf
;;;100    	return res;
000040  4620              MOV      r0,r4
;;;101    }
000042  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

                  |L22.68|
000044  0d0a4265          DCB      "\r\nBegin Write file...\r\n",0
000048  67696e20
00004c  57726974
000050  65206669
000054  6c652e2e
000058  2e0d0a00
                  |L22.92|
00005c  57726974          DCB      "Write data len:%d\r\n",0
000060  65206461
000064  7461206c
000068  656e3a25
00006c  640d0a00
                  |L22.112|
                          DCD      ||bw||
                  |L22.116|
                          DCD      file
                  |L22.120|
000078  57726974          DCB      "Write Error:%d\r\n",0
00007c  65204572
000080  726f723a
000084  25640d0a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L22.140|
00008c  57726974          DCB      "Writed data len:%d\r\n",0
000090  65642064
000094  61746120
000098  6c656e3a
00009c  25640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L22.164|
0000a4  57726974          DCB      "Write data over.\r\n",0
0000a8  65206461
0000ac  7461206f
0000b0  7665722e
0000b4  0d0a00  
0000b7  00                DCB      0

;*** Start embedded assembler ***

#line 1 "..\\FATFS\\exfuns\\fattester.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_fattester_c_mf_mount____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___11_fattester_c_mf_mount____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_fattester_c_mf_mount____REVSH|
#line 144
|__asm___11_fattester_c_mf_mount____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
