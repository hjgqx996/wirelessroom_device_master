; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\diskio.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\FWLIB\inc -I..\FWLIB\src -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FATFS\exfuns -I..\FATFS\src -I..\FATFS\src\option -I..\TEXT -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\KEY -IF:\文档\研究生项目\无线门禁系统\wirelessroom_device_master\USER\RTE\_Target -IC:\Work\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Work\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\diskio.crf ..\FATFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;37     //初始化磁盘
;;;38     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;39     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;40     )
;;;41     {
000002  4604              MOV      r4,r0
;;;42     	u8 res=0;	    
000004  2500              MOVS     r5,#0
;;;43     	switch(pdrv)
000006  b91c              CBNZ     r4,|L1.16|
;;;44     	{
;;;45     		case SD_CARD://SD卡
;;;46     			res=SD_Init();//SD卡初始化 
000008  f7fffffe          BL       SD_Init
00000c  4605              MOV      r5,r0
;;;47       			break;
00000e  e001              B        |L1.20|
                  |L1.16|
;;;48     //		case EX_FLASH://外部flash
;;;49     //			W25QXX_Init();
;;;50     //			FLASH_SECTOR_COUNT=2048*12;//W25Q1218,前12M字节给FATFS占用 
;;;51     // 			break;
;;;52     		default:
;;;53     			res=1; 
000010  2501              MOVS     r5,#1
000012  bf00              NOP                            ;43
                  |L1.20|
000014  bf00              NOP                            ;47
;;;54     	}		 
;;;55     	if(res)return  STA_NOINIT;
000016  b10d              CBZ      r5,|L1.28|
000018  2001              MOVS     r0,#1
                  |L1.26|
;;;56     	else return 0; //初始化成功
;;;57     }  
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;56
00001e  e7fc              B        |L1.26|
;;;58     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;158    #if _USE_IOCTL
;;;159    DRESULT disk_ioctl (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;160    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;161    	BYTE cmd,		/* Control code */
;;;162    	void *buff		/* Buffer to send/receive control data */
;;;163    )
;;;164    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;165    	DRESULT res;						  			     
;;;166    	if(pdrv==SD_CARD)//SD卡
00000a  bb46              CBNZ     r6,|L2.94|
;;;167    	{
;;;168    	    switch(cmd)
00000c  f1b90f00          CMP      r9,#0
000010  d009              BEQ      |L2.38|
000012  f1b90f01          CMP      r9,#1
000016  d013              BEQ      |L2.64|
000018  f1b90f02          CMP      r9,#2
00001c  d005              BEQ      |L2.42|
00001e  f1b90f03          CMP      r9,#3
000022  d119              BNE      |L2.88|
000024  e006              B        |L2.52|
                  |L2.38|
;;;169    	    {
;;;170    		    case CTRL_SYNC:
;;;171    				res = RES_OK; 
000026  2400              MOVS     r4,#0
;;;172    		        break;	 
000028  e018              B        |L2.92|
                  |L2.42|
;;;173    		    case GET_SECTOR_SIZE:
;;;174    				*(DWORD*)buff = 512; 
00002a  f44f7000          MOV      r0,#0x200
00002e  6028              STR      r0,[r5,#0]
;;;175    		        res = RES_OK;
000030  2400              MOVS     r4,#0
;;;176    		        break;	 
000032  e013              B        |L2.92|
                  |L2.52|
;;;177    		    case GET_BLOCK_SIZE:
;;;178    				*(WORD*)buff = SDCardInfo.CardBlockSize;
000034  480c              LDR      r0,|L2.104|
000036  f8b00050          LDRH     r0,[r0,#0x50]  ; SDCardInfo
00003a  8028              STRH     r0,[r5,#0]
;;;179    		        res = RES_OK;
00003c  2400              MOVS     r4,#0
;;;180    		        break;	 
00003e  e00d              B        |L2.92|
                  |L2.64|
;;;181    		    case GET_SECTOR_COUNT:
;;;182    		        *(DWORD*)buff = SDCardInfo.CardCapacity/512;
000040  4809              LDR      r0,|L2.104|
000042  f44f7200          MOV      r2,#0x200
000046  2300              MOVS     r3,#0
000048  e9d07112          LDRD     r7,r1,[r0,#0x48]
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       __aeabi_ldivmod
000052  6028              STR      r0,[r5,#0]
;;;183    		        res = RES_OK;
000054  2400              MOVS     r4,#0
;;;184    		        break;
000056  e001              B        |L2.92|
                  |L2.88|
;;;185    		    default:
;;;186    		        res = RES_PARERR;
000058  2404              MOVS     r4,#4
;;;187    		        break;
00005a  bf00              NOP      
                  |L2.92|
00005c  e000              B        |L2.96|
                  |L2.94|
;;;188    	    }
;;;189    //	}else if(pdrv==EX_FLASH)	//外部FLASH  
;;;190    //	{
;;;191    //	    switch(cmd)
;;;192    //	    {
;;;193    //		    case CTRL_SYNC:
;;;194    //				res = RES_OK; 
;;;195    //		        break;	 
;;;196    //		    case GET_SECTOR_SIZE:
;;;197    //		        *(WORD*)buff = FLASH_SECTOR_SIZE;
;;;198    //		        res = RES_OK;
;;;199    //		        break;	 
;;;200    //		    case GET_BLOCK_SIZE:
;;;201    //		        *(WORD*)buff = FLASH_BLOCK_SIZE;
;;;202    //		        res = RES_OK;
;;;203    //		        break;	 
;;;204    //		    case GET_SECTOR_COUNT:
;;;205    //		        *(DWORD*)buff = FLASH_SECTOR_COUNT;
;;;206    //		        res = RES_OK;
;;;207    //		        break;
;;;208    //		    default:
;;;209    //		        res = RES_PARERR;
;;;210    //		        break;
;;;211    //	    }
;;;212    	}else res=RES_ERROR;//其他的不支持
00005e  2401              MOVS     r4,#1
                  |L2.96|
;;;213        return res;
000060  4620              MOV      r0,r4
;;;214    }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;215    #endif
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      SDCardInfo

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;71     //count:需要读取的扇区数
;;;72     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;73     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;74     	BYTE *buff,		/* Data buffer to store read data */
;;;75     	DWORD sector,	/* Sector address (LBA) */
;;;76     	UINT count		/* Number of sectors to read (1..128) */
;;;77     )
;;;78     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;79     	u8 res=0; 
00000c  f04f0800          MOV      r8,#0
;;;80         if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L3.24|
000012  2004              MOVS     r0,#4
                  |L3.20|
;;;81     	switch(pdrv)
;;;82     	{
;;;83     		case SD_CARD://SD卡
;;;84     			res=SD_ReadDisk(buff,sector,count);	 
;;;85     			while(res)//读出错
;;;86     			{
;;;87     				SD_Init();	//重新初始化SD卡
;;;88     				res=SD_ReadDisk(buff,sector,count);	
;;;89     				//printf("sd rd error:%d\r\n",res);
;;;90     			}
;;;91     			break;
;;;92     //		case EX_FLASH://外部flash
;;;93     //			for(;count>0;count--)
;;;94     //			{
;;;95     //				W25QXX_Read(buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;96     //				sector++;
;;;97     //				buff+=FLASH_SECTOR_SIZE;
;;;98     //			}
;;;99     //			res=0;
;;;100    //			break;
;;;101    		default:
;;;102    			res=1; 
;;;103    	}
;;;104       //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;105        if(res==0x00)return RES_OK;	 
;;;106        else return RES_ERROR;	   
;;;107    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  b995              CBNZ     r5,|L3.64|
00001a  b2e2              UXTB     r2,r4                 ;84
00001c  4639              MOV      r1,r7                 ;84
00001e  4630              MOV      r0,r6                 ;84
000020  f7fffffe          BL       SD_ReadDisk
000024  4680              MOV      r8,r0                 ;84
000026  e007              B        |L3.56|
                  |L3.40|
000028  f7fffffe          BL       SD_Init
00002c  b2e2              UXTB     r2,r4                 ;88
00002e  4639              MOV      r1,r7                 ;88
000030  4630              MOV      r0,r6                 ;88
000032  f7fffffe          BL       SD_ReadDisk
000036  4680              MOV      r8,r0                 ;88
                  |L3.56|
000038  f1b80f00          CMP      r8,#0                 ;85
00003c  d1f4              BNE      |L3.40|
00003e  e002              B        |L3.70|
                  |L3.64|
000040  f04f0801          MOV      r8,#1                 ;102
000044  bf00              NOP                            ;81
                  |L3.70|
000046  bf00              NOP                            ;91
000048  f1b80f00          CMP      r8,#0                 ;105
00004c  d101              BNE      |L3.82|
00004e  2000              MOVS     r0,#0                 ;105
000050  e7e0              B        |L3.20|
                  |L3.82|
000052  2001              MOVS     r0,#1                 ;106
000054  e7de              B        |L3.20|
;;;108    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;59     //获得磁盘状态
;;;60     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;61     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;62     )
;;;63     { 
;;;64     	return 0;
000002  2000              MOVS     r0,#0
;;;65     } 
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;114    #if _USE_WRITE
;;;115    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;116    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;117    	const BYTE *buff,	/* Data to be written */
;;;118    	DWORD sector,		/* Sector address (LBA) */
;;;119    	UINT count			/* Number of sectors to write (1..128) */
;;;120    )
;;;121    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;122    	u8 res=0;  
00000c  f04f0800          MOV      r8,#0
;;;123        if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L5.24|
000012  2004              MOVS     r0,#4
                  |L5.20|
;;;124    	switch(pdrv)
;;;125    	{
;;;126    		case SD_CARD://SD卡
;;;127    			res=SD_WriteDisk((u8*)buff,sector,count);
;;;128    			while(res)//写出错
;;;129    			{
;;;130    				SD_Init();	//重新初始化SD卡
;;;131    				res=SD_WriteDisk((u8*)buff,sector,count);	
;;;132    				//printf("sd wr error:%d\r\n",res);
;;;133    			}
;;;134    			break;
;;;135    //		case EX_FLASH://外部flash
;;;136    //			for(;count>0;count--)
;;;137    //			{										    
;;;138    //				W25QXX_Write((u8*)buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;139    //				sector++;
;;;140    //				buff+=FLASH_SECTOR_SIZE;
;;;141    //			}
;;;142    //			res=0;
;;;143    //			break;
;;;144    		default:
;;;145    			res=1; 
;;;146    	}
;;;147        //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;148        if(res == 0x00)return RES_OK;	 
;;;149        else return RES_ERROR;	
;;;150    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L5.24|
000018  b995              CBNZ     r5,|L5.64|
00001a  b2e2              UXTB     r2,r4                 ;127
00001c  4639              MOV      r1,r7                 ;127
00001e  4630              MOV      r0,r6                 ;127
000020  f7fffffe          BL       SD_WriteDisk
000024  4680              MOV      r8,r0                 ;127
000026  e007              B        |L5.56|
                  |L5.40|
000028  f7fffffe          BL       SD_Init
00002c  b2e2              UXTB     r2,r4                 ;131
00002e  4639              MOV      r1,r7                 ;131
000030  4630              MOV      r0,r6                 ;131
000032  f7fffffe          BL       SD_WriteDisk
000036  4680              MOV      r8,r0                 ;131
                  |L5.56|
000038  f1b80f00          CMP      r8,#0                 ;128
00003c  d1f4              BNE      |L5.40|
00003e  e002              B        |L5.70|
                  |L5.64|
000040  f04f0801          MOV      r8,#1                 ;145
000044  bf00              NOP                            ;124
                  |L5.70|
000046  bf00              NOP                            ;134
000048  f1b80f00          CMP      r8,#0                 ;148
00004c  d101              BNE      |L5.82|
00004e  2000              MOVS     r0,#0                 ;148
000050  e7e0              B        |L5.20|
                  |L5.82|
000052  2001              MOVS     r0,#1                 ;149
000054  e7de              B        |L5.20|
;;;151    #endif
                          ENDP


                          AREA ||i.ff_memalloc||, CODE, READONLY, ALIGN=1

                  ff_memalloc PROC
;;;224    //动态分配内存
;;;225    void *ff_memalloc (UINT size)			
000000  b510              PUSH     {r4,lr}
;;;226    {
000002  4604              MOV      r4,r0
;;;227    	return (void*)mymalloc(SRAMIN,size);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       mymalloc
;;;228    }
00000c  bd10              POP      {r4,pc}
;;;229    //释放内存
                          ENDP


                          AREA ||i.ff_memfree||, CODE, READONLY, ALIGN=1

                  ff_memfree PROC
;;;229    //释放内存
;;;230    void ff_memfree (void* mf)		 
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232    	myfree(SRAMIN,mf);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       myfree
;;;233    }
00000c  bd10              POP      {r4,pc}
;;;234    
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;219    //15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */                                                                                                                                                                                                                                                
;;;220    DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;221    {				 
;;;222    	return 0;
;;;223    }			 
000002  4770              BX       lr
;;;224    //动态分配内存
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  FLASH_SECTOR_COUNT
000000  6000              DCW      0x6000

;*** Start embedded assembler ***

#line 1 "..\\FATFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___8_diskio_c_e3159e14____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REVSH|
#line 144
|__asm___8_diskio_c_e3159e14____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
